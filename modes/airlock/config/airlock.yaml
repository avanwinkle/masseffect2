#config_version=5

#####
# AIRLOCK MODE
#
# This is the sister config to lockhandler.yaml, but simpler. The FAST hardware
# setup uses separate ball devices for missionselect and ball lock, so the
# complex logic handling of lockhandler is no longer necessary.
#####

mode:
  start_events: start_mode_lockhandler
  stop_events: ball_will_end
  code: airlock.Airlock
  priority: 1000

mode_settings:
  ball_device: bd_lock
  lock_device: fmball_lock

event_player:
  mode_airlock_started:
    - disable_captive
  ball_hold_missionselect_hold_held_ball:
    - start_mode_missionselect
    # Missionselect delays for the slide queue, but disable flippers immediately
    - flippers_off
    # Emergency event to ensure the hold doesn't stay on too long
    - emergency_disable_hold|15s
  mode_missionselect_will_stop:
    - flippers_on
  # Relay these events to be agnostic with lockhandler
  sw_lock_entrance_active{mode["global"].active and mode.device.multiball_locks.fmball_lock.enabled}:
    overlord_ball_will_lock{device.achievements.arrival.state=="disabled"}:
      total_balls_locked:
        value: device.multiball_locks.fmball_lock.locked_balls + 1
        type: int
    arrival_ball_will_lock{device.achievements.arrival.state!="disabled"}:
      total_balls_locked:
        value: device.multiball_locks.fmball_lock.locked_balls + 1
        type: int
  # Hold open the gates if no balls are there, or quickly pop the gates
  # if a ball is there that we don't want to lock or hold
  # TODO: Integrate airlock and lockhandler and utilize bypass_lock logic
  s_airlock_entrance_active.1{not device.multiball_locks.fmball_lock.enabled and (device.ball_holds.captive_hold.balls_held>0 or not device.ball_holds.captive_hold.enabled)}:
    - bypass_lock_release_pulse_long{device.ball_devices.bd_lock.balls==0}
    - bypass_lock_release_pulse_short{device.ball_devices.bd_lock.balls>0}
  # Delay the release of suicide balls
  infiltration_specialist_selected: release_suicide_hold|2s
  longwalk_specialist_selected: release_suicide_hold|2s
  ball_hold_captive_hold_held_ball:
    - enable_captive_1{device.ball_devices.bd_lock.balls==1}
    - enable_captive_2{device.ball_devices.bd_lock.balls==2}
    - enable_captive_3{device.ball_devices.bd_lock.balls==3}

variable_player:
  overlord_ball_will_lock:
    persist_lock:
      action: set
      int: 0
  arrival_ball_will_lock:
    persist_lock:
      action: set
      int: 0
  enable_fmball_lock:
    persist_lock: 1
  # When switching from Overlord to Arrival, reset the lock state
  start_mode_collectorship_base:
    persist_lock:
      action: set
      int: 0

queue_relay_player:
  mode_missionselect_starting:
    post: check_slide_queue
    wait_for: slide_queue_clear

ball_saves:
  airlock_save:
    balls_to_save: 1
    enable_events:
      - balldevice_bd_lock_ejecting_ball
      - bypass_lock_release_pulse_short
    active_time: 3s
    auto_launch: true

ball_holds:
  missionselect_hold:
    balls_to_hold: 1
    hold_devices: bd_hold
    debug: true
    enable_events:
      - enable_airlock_missionselect_hold
      # Listen directly to this event, for expediency
      - s_left_ramp_exit_active{mode.field.active and (current_player.status_garrus==2 or current_player.status_samara==2)}
    disable_events:
      - mode_field_stopped
      - mode_missionselect_stopped
      # Always compare player_num because players can get added during others' turns
      - player_available_missions{player_num==current_player.number and value<=0}
    release_all_events:
      - mission_intro_complete
      - emergency_disable_hold
  suicide_hold:
    balls_to_hold: 1
    hold_devices: bd_hold
    debug: true
    enable_events:
      - infiltration_complete
      - longwalk_complete
      - tubes_complete
    disable_events: mode_suicide_huddle_will_stop
    release_all_events: release_suicide_hold
  captive_hold:
    balls_to_hold: 1
    debug: true
    hold_devices: bd_lock
    enable_events: enable_captive
    disable_events: disable_captive
    release_all_events: release_captive, disable_captive

multiball_locks:
  fmball_lock:
    balls_to_lock: 3
    balls_to_replace: 2
    lock_devices: bd_lock
    reset_count_for_current_player_events:
      - fmball_stopped
      - start_mode_collectorship_base
      - start_mode_suicide_base
    enable_events:
      - enable_fmball_lock
      - mode_field_started{current_player.persist_lock>0}
    disable_events:
      - mode_field_will_stop{device.multiball_locks.fmball_lock.locked_balls==2}
      - multiball_lock_fmball_lock_locked_ball
      - start_mode_collectorship_base
      - start_mode_derelictreaper
      - start_mode_suicide_base
    debug: true

counters:
  # We use a counter so we can consolidate multiple events into one "hit"
  captive_ball:
    enable_events:
      - enable_captive
      - cancel_lock_release_pulse{device.ball_devices.bd_lock.balls}
      - ball_hold_captive_hold_held_ball
    disable_events:
      - disable_captive
      - bypass_lock_release_pulse_short
      - bypass_lock_release_pulse_long
      - ball_hold_captive_hold_balls_released
    count_events: captive_ball_1_hit, captive_ball_2_hit, captive_ball_3_hit
    multiple_hit_window: 500ms
    events_when_hit: captive_ball_hit

shots:
  # One shot for each, so incoming balls don't trigger lesser captive hits
  captive_ball_1:
    hit_events: s_lock_1_inactive
    enable_events: enable_captive_1
    disable_events: disable_captive, enable_captive_2
  captive_ball_2:
    hit_events: s_lock_1_inactive, s_lock_2_inactive
    enable_events: enable_captive_2
    disable_events: disable_captive, enable_captive_3
  captive_ball_3:
    hit_events: s_lock_1_inactive, s_lock_2_inactive, s_lock_3_inactive
    enable_events: enable_captive_3
    disable_events: disable_captive

show_player:
  ball_save_airlock_save_enabled:
    color_flashing_default:
      key: airlock_save_show
      speed: 3
      show_tokens:
        leds: l_ball_save
        color: color_shields
  ball_save_airlock_save_disabled:
    airlock_save_show:
      action: stop
